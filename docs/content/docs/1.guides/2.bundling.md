---
title: Bundling Remote Scripts
description: Optimize third-party scripts by bundling them with your app.
---

## Background

When you use scripts from other sites on your website, you rely on another server to load these scripts. This can slow down your site and raise concerns about safety and privacy.

### Common problems

- Slower website because it takes time to connect to other servers.
- Safety risks if the other server is hacked.
- Your visitors' data being used inappropriately by other servers.
- Ad blockers or privacy tools might stop these scripts from working.

### How to fix it

By bundling these scripts, you can host them yourself, which helps avoid these issues and keeps your site running smoothly.

## How it Works

During the build process, your code is checked to find any instances of `useScript` that need to be bundled.

When a script is identified for bundling, it's downloaded and saved as a public asset at `/_scripts/[hash].js`. Here, `[hash]` represents the hash of the script's URL.

**Important points about bundling:**

1. You need to have static values for your script URLs and bundling settings.

::code-group

```ts [Input - Pre Build]
// GOOD - Static values allow for bundling
useScript('https://example.com/script.js', {
  bundle: true
})
// BAD - Dynamic values prevent bundling
useScript(scriptSrc, {
  bundle: canBundle
})
```

```ts [Output - Post Build]
// GOOD - Script is bundled
useScript('/_scripts/[hash].js', {})
// BAD - Script is not bundled (remains the same)
useScript(scriptSrc, {
  bundle: canBundle
})
```

::

2. If the original script changes without a URL change, the bundled version won't update in the browser cache. To handle this, use a versioned URL or a cache-busting query parameter.

## Usage

Scripts can be bundled individually or on a global scale using specific settings.

### Script Options

To decide if an individual script should be bundled, use the `bundle` option.

::code-group

```ts [useScript]
// Opt-in to bundle this specific script
useScript('https://example.com/script.js', {
  bundle: true,
})
```

```ts [Registry Script]
// Registry script must support bundling
useScriptGoogleAnalytics('https://example.com/script.js', {
  bundle: true,
})
```
::

### Global Bundling

Adjust the default behavior for all scripts using the Nuxt Config. This example sets all scripts to be bundled by default.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  scripts: {
    defaultScriptOptions: {
      bundle: true,
    }
  }
})
```

### Build-time vs Runtime Behavior

Understanding when bundling happens and how it affects runtime behavior is crucial for effective usage.

#### Build-time Processing

Bundling occurs during the build phase through static code analysis:

```ts
// ✅ Bundled at build-time (static values)
useScript('https://example.com/script.js', { bundle: true })

// ❌ Cannot be bundled (dynamic values)
const scriptUrl = computed(() => getScriptUrl())
useScript(scriptUrl, { bundle: dynamic.value })
```

#### Runtime Behavior

At runtime, bundled scripts behave differently:

```ts
// Original code
useScript('https://example.com/script.js', { bundle: true })

// After build transformation
useScript('/_scripts/abc123.js', {})
```

**Important**: Once bundled, you lose access to the original URL at runtime. If you need the original URL for tracking or analytics, store it separately.

#### Static URL Requirements

For bundling to work, the transformer requires **completely static values**:

::code-group

```ts [✅ Valid for Bundling]
// Static string literals
useScript('https://cdn.example.com/lib.js', { bundle: true })

// Static template literals (no variables)
useScript(`https://cdn.example.com/lib.js`, { bundle: true })

// Constants defined at module level
const SCRIPT_URL = 'https://cdn.example.com/lib.js'
useScript(SCRIPT_URL, { bundle: true })
```

```ts [❌ Cannot be Bundled]
// Runtime variables
const url = getScriptUrl()
useScript(url, { bundle: true })

// Computed values
const scriptUrl = computed(() => `https://cdn.example.com/${version.value}.js`)
useScript(scriptUrl, { bundle: true })

// Environment variables at runtime
useScript(process.env.SCRIPT_URL, { bundle: true })

// Props or reactive values
useScript(props.scriptUrl, { bundle: true })
```

::

#### Manual Injection Patterns

When automatic bundling isn't possible, you can manually inject bundled scripts:

```ts [Manual Bundling Workaround]
// 1. Bundle during build with static URL
const staticScript = useScript('https://cdn.example.com/static.js', {
  bundle: true,
  trigger: 'manual' // Don't auto-load
})

// 2. Conditionally load based on runtime logic
function loadScript() {
  if (shouldLoadScript.value) {
    staticScript.load()
  }
}

// 3. Alternative: Use multiple static configurations
const scriptVariants = {
  dev: useScript('https://cdn.example.com/dev.js', { bundle: true, trigger: 'manual' }),
  prod: useScript('https://cdn.example.com/prod.js', { bundle: true, trigger: 'manual' })
}

// Load appropriate variant
const currentScript = computed(() =>
  isDev ? scriptVariants.dev : scriptVariants.prod
)
```

#### Working with Dynamic URLs

For truly dynamic scenarios, consider these patterns:

```ts [Dynamic URL Strategies]
// Option 1: Pre-bundle known variants
const analytics = {
  google: useScript('https://www.googletagmanager.com/gtag/js', { bundle: true }),
  plausible: useScript('https://plausible.io/js/script.js', { bundle: true })
}

// Option 2: Fallback to runtime loading
function loadDynamicScript(url: string) {
  // This won't be bundled, but will work at runtime
  return useScript(url, {
    bundle: false, // Explicitly disable
    trigger: 'manual'
  })
}

// Option 3: Use server-side bundling
// Store script content in your bundle and inject manually
const { $script } = useNuxtApp()
$script.add({
  innerHTML: await $fetch('/api/dynamic-script-content'),
})
```

### Limitations and Workarounds

While many scripts can be bundled, there are exceptions you need to be aware of.

#### Technical Limitations

**Scripts that cannot be bundled:**
- Scripts with dynamic URLs determined at runtime
- Scripts requiring specific domain origins for CORS
- Scripts that self-modify or inject additional scripts dynamically
- Scripts requiring real-time updates without cache invalidation

**Registry-specific limitations:**
- Require tracking all user interactions for security reasons, like fraud detection (e.g., Stripe)
- Must be served directly from their original source to function properly (e.g., Fathom Analytics)
- Some analytics scripts that rely on referrer headers from their original domain

#### Workarounds for Common Issues

```ts [Common Bundling Workarounds]
// Issue: Need original URL for analytics
const originalUrl = 'https://cdn.example.com/analytics.js'
const script = useScript(originalUrl, { bundle: true })

// Store original URL separately for tracking
const trackingData = {
  originalUrl,
  bundledUrl: script.src // Available after bundling
}

// Issue: Version-specific scripts
// Pre-bundle multiple versions
const versions = ['1.0.0', '1.1.0', '1.2.0']
const bundledVersions = Object.fromEntries(
  versions.map(v => [
    v,
    useScript(`https://cdn.example.com/lib-${v}.js`, {
      bundle: true,
      trigger: 'manual'
    })
  ])
)

// Load specific version at runtime
function loadVersion(version: string) {
  bundledVersions[version]?.load()
}
```

Scripts from known registries are pre-configured to either allow or disallow bundling. For your own scripts, you'll need to decide whether bundling is appropriate on a case-by-case basis.

### Change Asset Behavior

Use the `assets` option in your configuration to customize how scripts are bundled, such as changing the output directory for the bundled scripts.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  scripts: {
    assets: {
      prefix: '/_custom-script-path/',
    }
  }
})
```

More configuration options will be available in future updates.
